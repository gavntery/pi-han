// ----------------------------------------------------------------------------
// PixInsight JavaScript Runtime API - PJSR Version 1.0
// ----------------------------------------------------------------------------
// LinearPatternSubtraction.js - Released 2019-12-23T12:01:37Z
// ----------------------------------------------------------------------------
//
// Pattern Correction Scripts
//
// Copyright (c) 2019 Vicent Peris (OAUV). All Rights Reserved.
//
// Redistribution and use in both source and binary forms, with or without
// modification, is permitted provided that the following conditions are met:
//
// 1. All redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//
// 2. All redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the names "PixInsight" and "Pleiades Astrophoto", nor the names
//    of their contributors, may be used to endorse or promote products derived
//    from this software without specific prior written permission. For written
//    permission, please contact info@pixinsight.com.
//
// 4. All products derived from this software, in any form whatsoever, must
//    reproduce the following acknowledgment in the end-user documentation
//    and/or other materials provided with the product:
//
//    "This product is based on software from the PixInsight project, developed
//    by Pleiades Astrophoto and its contributors (http://pixinsight.com/)."
//
//    Alternatively, if that is where third-party acknowledgments normally
//    appear, this acknowledgment must be reproduced in the product itself.
//
// THIS SOFTWARE IS PROVIDED BY PLEIADES ASTROPHOTO AND ITS CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL PLEIADES ASTROPHOTO OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, BUSINESS
// INTERRUPTION; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; AND LOSS OF USE,
// DATA OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// ----------------------------------------------------------------------------

#include <pjsr/DataType.jsh>
#include <pjsr/ImageOp.jsh>
#include <pjsr/ReadTextOptions.jsh>
#include <pjsr/SampleType.jsh>
#include <pjsr/UndoFlag.jsh>

#feature-id Utilities > LinearPatternSubtraction

#feature-info  <b>LinearPatternSubtraction version 1.0</b><br/>\
   <br/>\
   A script to correct residual column or row patterns in a list of images.<br/>\
   <br/>\
   Copyright &copy; 2019 Vicent Peris (OAUV). All Rights Reserved.

#ifndef __PI_ENCODED_VERSION__
#error This script requires PixInsight version 1.8.7 or higher.
#endif
#iflt __PI_ENCODED_VERSION__ "000100080007"
#error This script requires PixInsight version 1.8.7 or higher.
#endif

#define TITLE "LinearPatternSubtraction"
#define VERSION "1.0"
#define POSTFIX "_lps"

#include "CommonFunctions.jsh"
#include "LinearPatternSubtractionGUI.jsh"

/*
 * LinearPatternSubtraction
 *
 * Script to correct residual column or row patterns in a list of images.
 *
 * This script reuses some code written by Georg Viehoever in the
 * CanonBandingReduction script and applies the column or row correction in the
 * multiscale context. The engine also includes outlier rejection for a more
 * robust statistical evaluation.
 *
 * The script corrects entire rows or columns, but it can also correct partial
 * rows or columns by reading a defect table generated by CosmeticCorrection.
 * Thus, if you want to correct partial rows or columns, you should first run
 * CosmeticCorrection, manually create the defect list, and save it to a text
 * file.
 */

//------------------------------------------------------------------------------

/*
 * Script parameters.
 */
function LPSParameters()
{
   this.__base__ = Object;
   this.__base__();

   this.reset = function()
   {
      this.inputFiles = new Array;
      this.targetIsActiveImage = true;
      this.closeFormerWorkingImages = false;
      this.outputDir = "";
      this.correctColumns = true;
      this.correctEntireImage = false;
      this.defectTableFilePath = "";
      this.postfix = POSTFIX;
      this.layersToRemove = 9;
      this.rejectionLimit = 3;
      this.globalRejection = true;
      this.globalRejectionLimit = 5;
      this.backgroundReferenceLeft = 0;
      this.backgroundReferenceTop = 0;
      this.backgroundReferenceWidth = 512;
      this.backgroundReferenceHeight = 512;
   };

   this.ensureValid = function()
   {
      let inputFiles = [];
      for ( let i = 0; i < this.inputFiles.length; ++i )
      {
         let inputFile = this.inputFiles[i].trim();
         if ( inputFile.length > 0 )
            inputFiles.push( inputFile );
      }
      this.inputFiles = inputFiles;
      this.outputDir.trim();
      this.defectTableFilePath.trim();
      this.postfix.trim();
      if ( this.postfix.length == 0 )
         this.postfix = POSTFIX;
   };

   this.import = function()
   {
      if ( Parameters.has( "inputFiles" ) )
         this.inputFiles                  = Parameters.get( "inputFiles" ).split( '|' );
      if ( Parameters.has( "targetIsActiveImage" ) )
         this.targetIsActiveImage         = Parameters.getBoolean( "targetIsActiveImage" );
      if ( Parameters.has( "closeFormerWorkingImages" ) )
         this.closeFormerWorkingImages    = Parameters.getBoolean( "closeFormerWorkingImages" );
      if ( Parameters.has( "outputDir" ) )
         this.outputDir                   = Parameters.get( "outputDir" );
      if ( Parameters.has( "correctColumns" ) )
         this.correctColumns              = Parameters.getBoolean( "correctColumns" );
      if ( Parameters.has( "correctEntireImage" ) )
         this.correctEntireImage          = Parameters.getBoolean( "correctEntireImage" );
      if ( Parameters.has( "defectTableFilePath" ) )
         this.defectTableFilePath         = Parameters.get( "defectTableFilePath" );
      if ( Parameters.has( "postfix" ) )
         this.postfix                     = Parameters.get( "postfix" );
      if ( Parameters.has( "layersToRemove" ) )
         this.layersToRemove              = Parameters.getInteger( "layersToRemove" );
      if ( Parameters.has( "rejectionLimit" ) )
         this.rejectionLimit              = Parameters.getInteger( "rejectionLimit" );
      if ( Parameters.has( "globalRejection" ) )
         this.globalRejection             = Parameters.getBoolean( "globalRejection" );
      if ( Parameters.has( "globalRejectionLimit" ) )
         this.globalRejectionLimit        = Parameters.getInteger( "globalRejectionLimit" );
      if ( Parameters.has( "backgroundReferenceLeft" ) )
         this.backgroundReferenceLeft     = Parameters.getInteger( "backgroundReferenceLeft" );
      if ( Parameters.has( "backgroundReferenceTop" ) )
         this.backgroundReferenceTop      = Parameters.getInteger( "backgroundReferenceTop" );
      if ( Parameters.has( "backgroundReferenceWidth" ) )
         this.backgroundReferenceWidth    = Parameters.getInteger( "backgroundReferenceWidth" );
      if ( Parameters.has( "backgroundReferenceHeight" ) )
         this.backgroundReferenceHeight   = Parameters.getInteger( "backgroundReferenceHeight" );

      this.ensureValid();
   };

   this.export = function()
   {
      Parameters.set( "inputFiles",                this.inputFiles.join( '|' ) );
      Parameters.set( "targetIsActiveImage",       this.targetIsActiveImage );
      Parameters.set( "closeFormerWorkingImages",  this.closeFormerWorkingImages );
      Parameters.set( "outputDir",                 this.outputDir );
      Parameters.set( "correctColumns",            this.correctColumns );
      Parameters.set( "correctEntireImage",        this.correctEntireImage );
      Parameters.set( "defectTableFilePath",       this.defectTableFilePath );
      Parameters.set( "postfix",                   this.postfix );
      Parameters.set( "layersToRemove",            this.layersToRemove );
      Parameters.set( "rejectionLimit",            this.rejectionLimit );
      Parameters.set( "globalRejection",           this.globalRejection );
      Parameters.set( "globalRejectionLimit",      this.globalRejectionLimit );
      Parameters.set( "backgroundReferenceLeft",   this.backgroundReferenceLeft );
      Parameters.set( "backgroundReferenceTop",    this.backgroundReferenceTop );
      Parameters.set( "backgroundReferenceWidth",  this.backgroundReferenceWidth );
      Parameters.set( "backgroundReferenceHeight", this.backgroundReferenceHeight );
   };

   this.reset();
}

LPSParameters.prototype = new Object;

// ----------------------------------------------------------------------------

/*
 * These are the image windows and images that will be used by the script
 * engine.
 */
function DefineWindowsAndImages( globalRejection )
{
   // Force the active window to be in 32-bit float format.
   ImageWindow.activeWindow.setSampleFormat( 32, true );

   this.targetImageWindow = ImageWindow.activeWindow;

   this.targetImage = new Image( this.targetImageWindow.mainView.image.width,
                                 this.targetImageWindow.mainView.image.height,
                                 this.targetImageWindow.mainView.image.numberOfChannels,
                                 this.targetImageWindow.mainView.image.colorSpace,
                                 this.targetImageWindow.mainView.image.bitsPerSample,
                                 SampleType_Real );

   this.targetImage.apply( this.targetImageWindow.mainView.image );

   /*
    * The large-scale component image.
    * The initial image is a clone of the target image. The contents of this
    * image will be generated by the MultiscaleIsolation function.
    */
   this.LSImageWindow = new ImageWindow( this.targetImage.width,
                                         this.targetImage.height,
                                         this.targetImage.numberOfChannels,
                                         32, true, false, "LS" );

   this.LSImage = new Image( this.targetImageWindow.mainView.image.width,
                             this.targetImageWindow.mainView.image.height,
                             this.targetImageWindow.mainView.image.numberOfChannels,
                             this.targetImageWindow.mainView.image.colorSpace,
                             this.targetImageWindow.mainView.image.bitsPerSample,
                             SampleType_Real );

   /*
    * The small-scale component image.
    * We'll get the column statistics from this image. We copy the targetImage
    * content to this image; the large-scale components of this image will be
    * removed by the MultiscaleIsolation function.
    */
   this.SSImageWindow = new ImageWindow( this.targetImage.width,
                                         this.targetImage.height,
                                         this.targetImage.numberOfChannels,
                                         32, true, false, "SS" );

   this.SSImage = new Image( this.targetImage.width,
                             this.targetImage.height,
                             this.targetImage.numberOfChannels,
                             this.targetImage.colorSpace,
                             this.targetImage.bitsPerSample,
                             SampleType_Real );

   this.SSImage.apply( this.targetImageWindow.mainView.image );

   /*
    * The image containing the line pattern.
    * The pattern is calculated and subtracted from the target image by the
    * PatternSubtraction function.
    */
   this.patternImageWindow = new ImageWindow( this.targetImage.width,
                                              this.targetImage.height,
                                              this.targetImage.numberOfChannels,
                                              32, true, false, "pattern" );

   this.patternImage = new Image( this.targetImage.width,
                                  this.targetImage.height,
                                  this.targetImage.numberOfChannels,
                                  this.targetImage.colorSpace,
                                  this.targetImage.bitsPerSample,
                                  SampleType_Real );

   this.patternImage.fill( 0 );

   if ( globalRejection )
   {
      this.clippingMask = new Image( this.targetImage.width,
                                     this.targetImage.height,
                                     this.targetImage.numberOfChannels,
                                     this.targetImage.colorSpace,
                                     this.targetImage.bitsPerSample,
                                     SampleType_Real );

      this.clippingMask.apply( this.targetImageWindow.mainView.image );
   }
}

// ----------------------------------------------------------------------------

/*
 * Function to perform a pixel rejection in the small-scale image based on the
 * pixel values of the target image. The rejected pixel values are set to 1 in
 * the small-scale image; this way, they will be all rejected when performing
 * the in-line pixel rejection in the PatternSubtraction function since the
 * rejection high value will be always below 1.
 */
function GlobalRejection( targetImage, SSImage, LSImage, clippingMask,
                          backgroundMedian, backgroundMAD, globalRejectionLimit )
{
   let globalRejectionHigh = backgroundMedian + ( backgroundMAD * globalRejectionLimit );
   clippingMask.binarize( globalRejectionHigh );
   // Before applying the maximum operation between the clipping mask and
   // the small-scale component image, we need to add the median of
   // the sky background to the latter, since the median value of that image
   // is zero because we already subtracted the large-scale components.
   SSImage.apply( backgroundMedian, ImageOp_Add );
   SSImage.apply( clippingMask, ImageOp_Max );
   // After applying the maximum operation, we should subtract again the sky
   // background pedestal to keep the median value of the small-component image
   // to zero. This is needed because this image is used specifically
   // to calculate the defect deviations that should be removed from
   // the target image.
   SSImage.apply( backgroundMedian, ImageOp_Sub );
   console.writeln( format( "Global rejection high value: %9.7f", globalRejectionHigh ) );
}

// ----------------------------------------------------------------------------

/*
 * Generate the pattern image and subtract it from the target image.
 */
function PatternSubtraction( correctColumns, lines, targetImage, SSImage, patternImage, rejectionLimit )
{
   // Generate the line-patterned image.
   for ( let i = 0; i < lines.columnOrRow.length; ++i )
   {
      // Select the line specified in the line list.
      if ( correctColumns )
      {
         var lineRect = new Rect( 1, lines.endPixel[i] - lines.startPixel[i] + 1 );
         lineRect.moveTo( lines.columnOrRow[i], lines.startPixel[i] );
      }
      else
      {
         var lineRect = new Rect( lines.endPixel[i] - lines.startPixel[i] + 1, 1 );
         lineRect.moveTo( lines.startPixel[i], lines.columnOrRow[i] );
      }

      // Calculate the line statistics.
      var lineStatistics = new IterativeStatistics( SSImage, lineRect, rejectionLimit );
      // Store line median value into patternImage.
      // Please note that we apply the same line selection to this image,
      // so we fill only that line with its median value.
      patternImage.apply( lineStatistics.median, 1, lineRect );
   }
   // Finally we subtract the pattern image from the target image.
   targetImage.apply( patternImage, ImageOp_Sub );
}

// ----------------------------------------------------------------------------

/*
 * Script engine.
 */
function LPSEngine( outputFilePath,
                    correctColumns, correctEntireImage, defectTableFilePath,
                    layersToRemove,
                    backgroundReferenceLeft, backgroundReferenceTop,
                    backgroundReferenceWidth, backgroundReferenceHeight,
                    rejectionLimit, globalRejection, globalRejectionLimit )
{
   let engineTime = new ElapsedTime;

   // Define the needed image windows and images for the entire engine.
   var WI = new DefineWindowsAndImages( globalRejection );

   // Check if the defined background area is inside the image.
      if ( backgroundReferenceLeft + backgroundReferenceWidth > WI.targetImage.width ||
           backgroundReferenceTop + backgroundReferenceHeight > WI.targetImage.height )
         throw new Error( "Background reference area is out of bounds of the image" );

   // Calculate the median and MAD values of the background reference area.
   var background = new BackgroundStatistics( WI.targetImage,
                                              backgroundReferenceLeft, backgroundReferenceTop,
                                              backgroundReferenceWidth, backgroundReferenceHeight);

   // Generate the small and large-scale component images.
   console.writeln( "Isolating multiscale components" );
   console.flush();
   MultiscaleIsolation( WI.SSImage, WI.LSImage, layersToRemove );

   // Apply a small scale normalization to the already processed
   // small-scale component image. This way we adjust the local contrast
   // of the columns or rows, depending on the local illumination level
   // of the large-scale component image. This is needed because
   // the line structures lose contrast in higher illuminated areas,
   // thus affecting the statistics of the line.
   WI.SSImage.apply( WI.LSImage, ImageOp_Mul );
   WI.SSImage.apply( background.median, ImageOp_Div );

   // Perform a pixel rejection in the entire image
   // based on the pixel value of the target image.
   if ( globalRejection )
      GlobalRejection( WI.targetImage, WI.SSImage,
                       WI.LSImage, WI.clippingMask,
                       background.median, background.MAD, globalRejectionLimit );

   // Build the list of lines to be corrected.
   // This list includes both entire and partial columns or rows.
   console.writeln( "Building the list of pattern lines" );
   console.flush();
   if ( correctColumns )
   {
      var maxPixelPara = WI.targetImage.height - 1;
      var maxPixelPerp = WI.targetImage.width - 1;
   }
   else
   {
      var maxPixelPara = WI.targetImage.width - 1;
      var maxPixelPerp = WI.targetImage.height - 1;
   }

   // Read the defect table.
   var defectColumnOrRow = new Array;
   var defectStartPixel = new Array;
   var defectEndPixel = new Array;
   if ( defectTableFilePath != ( "" && undefined ) )
   {
      let tableLines = File.readLines( defectTableFilePath, ReadTextOptions_RemoveEmptyLines | ReadTextOptions_TrimLines );
      for ( let iTable = 0; iTable < tableLines.length; ++iTable )
      {
         let tokens = tableLines[iTable].split( " " );
         defectColumnOrRow.push( parseInt( tokens[1] ) );
         defectStartPixel.push( parseInt( tokens[2] ) );
         defectEndPixel.push( parseInt( tokens[3] ) );
      }
   }
   // Create the list of lines to be corrected.
   var lines = new LineList( correctEntireImage,
                             defectColumnOrRow, defectStartPixel, defectEndPixel,
                             maxPixelPara, maxPixelPerp )

   // Generate the line pattern and subtract it from the target image.
   console.writeln( "Correcting the line pattern" );
   console.flush();
   PatternSubtraction( correctColumns, lines,
                       WI.targetImage, WI.SSImage, WI.patternImage,
                       rejectionLimit );

   // Show the working images if the target image is the active image.
   if ( outputFilePath == undefined )
   {
      // Add the median pixel value of the large-scale component image
      // to the small-scale, the pattern and the target images.
      // This ensures that the median signal intensity in the product
      // images is the same than the original image before the script
      // execution. This also prevents having pixels values out of the [0,1]
      // range in these images, which is necessary for a correct visualization
      // once they are applied to their corresponding image windows.
      let LSImageMedian = WI.LSImage.median();
      WI.SSImage.apply( LSImageMedian, ImageOp_Add );
      WI.SSImage.truncate( 0, 1 );
      WI.patternImage.apply( LSImageMedian, ImageOp_Add );
      WI.patternImage.truncate( 0, 1 );
      var targetImageMedian = WI.targetImage.median();
      WI.targetImage.apply( targetImageMedian, ImageOp_Sub );
      WI.targetImage.apply( LSImageMedian, ImageOp_Add );
      WI.targetImage.truncate( 0, 1 );

      // Apply the working images to their corresponding image windows.
      WI.targetImageWindow.mainView.beginProcess();
      WI.targetImageWindow.mainView.image.apply( WI.targetImage );
      WI.targetImageWindow.mainView.endProcess();
      WI.SSImageWindow.mainView.beginProcess( UndoFlag_NoSwapFile );
      WI.SSImageWindow.mainView.image.apply( WI.SSImage );
      WI.SSImageWindow.mainView.endProcess();
      WI.LSImageWindow.mainView.beginProcess( UndoFlag_NoSwapFile );
      WI.LSImageWindow.mainView.image.apply( WI.LSImage );
      WI.LSImageWindow.mainView.endProcess();
      WI.patternImageWindow.mainView.beginProcess( UndoFlag_NoSwapFile );
      WI.patternImageWindow.mainView.image.apply( WI.patternImage );
      WI.patternImageWindow.mainView.endProcess();

      // Show the working images.
      WI.LSImageWindow.show();
      WI.SSImageWindow.show();
      WI.patternImageWindow.show();

      // Clean the working images.
      WI.targetImage.free();
      WI.SSImage.free();
      WI.LSImage.free();
      WI.patternImage.free();
      if ( globalRejection )
         WI.clippingMask.free();
   }
   else
   {
      // Save the processed image if the target is an image list.
      WI.targetImageWindow.mainView.beginProcess( UndoFlag_NoSwapFile );
      WI.targetImageWindow.mainView.image.apply( WI.targetImage );
      WI.targetImageWindow.mainView.endProcess();
      console.writeln( "Saving processed image to disk" );
      console.flush();

      WI.targetImageWindow.saveAs( outputFilePath, false, false, false, false );

      if ( File.exists( outputFilePath ) )
      {
         console.writeln( "Image saved to " + outputFilePath );
         console.flush();
      }
      else
         throw new Error( "Could not save image to " + outputFilePath );

      // Clean working images and close image windows.
      WI.targetImageWindow.forceClose();
      WI.LSImageWindow.forceClose();
      WI.SSImageWindow.forceClose();
      WI.patternImageWindow.forceClose();
      WI.targetImage.free();
      WI.SSImage.free();
      WI.LSImage.free();
      WI.patternImage.free();
      WI.clippingMask.free();
   }

   console.writeln( "<end><cbr><br>Engine processing time: " + engineTime.text );
}

//------------------------------------------------------------------------------

function main()
{
   if ( Parameters.isViewTarget )
      throw new Error( TITLE + " cannot be executed on views." );

   let parameters = new LPSParameters;
   parameters.import();

   let dialog = new LPSDialog( parameters );
   if ( dialog.execute() )
   {
      parameters = dialog.parameters;
      parameters.ensureValid();

      console.noteln( "<end><cbr><br>===============================" );
      console.noteln(               "LinearPatternSubtraction script" );
      console.noteln(               "(C) 2019 Vicent Peris (OAUV)" );
      console.noteln(               "===============================" );
      console.writeln();
      console.writeln( "* Working parameters" );
      console.writeln( "Target is active image: " + parameters.targetIsActiveImage );
      console.writeln( "Close former working images: " + parameters.closeFormerWorkingImages );
      console.writeln( "Input directory: " + parameters.inputDir );
      console.writeln( "Output directory: " + parameters.outputDir );
      console.writeln( "Correct columns: " + parameters.correctColumns );
      console.writeln( "Correct entire image: " + parameters.correctEntireImage );
      console.writeln( "Defect table file path: " + parameters.defectTableFilePath );
      console.writeln( "Target image extension: " + parameters.targetImageExtension );
      console.writeln( "Output image postfix: " + parameters.postfix );
      console.writeln( "Layers to remove: " + parameters.layersToRemove );
      console.writeln( "Rejection limit: " + parameters.rejectionLimit );
      console.writeln( "Global rejection: " + parameters.globalRejection );
      console.writeln( "Global rejection limit: " + parameters.globalRejectionLimit );
      console.writeln( "Background reference left: " + parameters.backgroundReferenceLeft );
      console.writeln( "Background reference top: " + parameters.backgroundReferenceTop );
      console.writeln( "Background reference width: " + parameters.backgroundReferenceWidth );
      console.writeln( "Background reference height: " + parameters.backgroundReferenceHeight );

      console.show();
      processEvents();

      if ( parameters.closeFormerWorkingImages )
      {
         if ( !ImageWindow.windowById( "pattern" ).isNull )
            ImageWindow.windowById( "pattern" ).forceClose();
         if ( !ImageWindow.windowById( "SS" ).isNull )
            ImageWindow.windowById( "SS" ).forceClose();
         if ( !ImageWindow.windowById( "LS" ).isNull )
            ImageWindow.windowById( "LS" ).forceClose();
         if ( !ImageWindow.windowById( "clipping_mask" ).isNull )
            ImageWindow.windowById( "clipping_mask" ).forceClose();
      }

      let T = new ElapsedTime;

      if ( parameters.targetIsActiveImage )
      {
         /*
          * Process only the active image.
          */
         console.noteln( "<end><cbr><br>* Processing active image." );
         console.flush();

         let outputFilePath;
         LPSEngine( outputFilePath,
                    parameters.correctColumns,
                    parameters.correctEntireImage,
                    parameters.defectTableFilePath,
                    parameters.layersToRemove,
                    parameters.backgroundReferenceLeft,
                    parameters.backgroundReferenceTop,
                    parameters.backgroundReferenceWidth,
                    parameters.backgroundReferenceHeight,
                    parameters.rejectionLimit,
                    parameters.globalRejection,
                    parameters.globalRejectionLimit );
      }
      else
      {
         /*
          * Process each image in the input files list.
          */
         for ( let i = 0; i < parameters.inputFiles.length; ++i )
         {
            console.noteln( format( "<end><cbr><br>* Processing image %d of %d", i+1, parameters.inputFiles.length ) );
            console.flush();

            // Get file name and build the output path
            // of the image to be processed by the engine.
            let fileName = File.extractName( parameters.inputFiles[i] );
            let outputDir = parameters.outputDir;
            if ( outputDir.length == 0 )
               outputDir = File.extractDrive( parameters.inputFiles[i] ) + File.extractDirectory( parameters.inputFiles[i] );
            let outputFilePath = outputDir + '/' + fileName + parameters.postfix + ".xisf";

            ImageWindow.open( parameters.inputFiles[i] )[0].show();
            LPSEngine( outputFilePath,
                       parameters.correctColumns,
                       parameters.correctEntireImage,
                       parameters.defectTableFilePath,
                       parameters.layersToRemove,
                       parameters.backgroundReferenceLeft,
                       parameters.backgroundReferenceTop,
                       parameters.backgroundReferenceWidth,
                       parameters.backgroundReferenceHeight,
                       parameters.rejectionLimit,
                       parameters.globalRejection,
                       parameters.globalRejectionLimit );

            processEvents();

            if ( console.abortRequested )
            {
               console.criticalln( "<end><cbr>&lt;* abort *&gt;" );
               return;
            }
         }
      }

      processEvents();
      console.writeln( "<end><cbr><br>Script processing time: " + T.text );
   }
}

main();

// ----------------------------------------------------------------------------
// EOF LinearPatternSubtraction.js - Released 2019-12-23T12:01:37Z
